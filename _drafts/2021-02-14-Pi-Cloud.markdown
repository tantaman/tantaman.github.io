---
layout: post
title:  "Pi Cloud"
tags: cloud architecture raspberry-pi
---
With services like `Herkou`, `AWS`, `Azure` and `Google Cloud`, coming up with and managing your own cloud architecture may be a dying art. Some might accuse me of showing my age, like professors of old who swore that their students must learn C and how to alloc & free.

Well I don't think that those professors were wrong. You'll inevitbly have to face these low level problems at some point in your career. While I think Joel goes a bit overboard (we're surrounded by abstraction that rarely, if ever, leak) this line of thinking reminds me of his article on [leaky abstractions](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/). tldr: at some point something lower in the stack breaks (or bubbles up), requiring you to understand how it works so you can fix (or accomodate) it.

The most absurd example I've seen of this in the workplace was a bug we had generating hashes of passwords. Developers in the `PHP` stack would call `hash_password` (when registering a user) or `check_pasword($user_input, $stored_hash)` when checking credentials. New accounts would get created, but the users could never log in. At the same time, the number of failed login attempts for previously registered users increased. Ultimately, the cause of the bug ended up being new servers we had installed which contained Intel chips that were generating incorrect SHA values. The abstraction leaked from the metal all the way up to application developers.

All that being said, you don't know which part of the stack is going to end up breaking in your future but some part, deep down, will break. Given that, a good developer should have a passing familiarity with all levels of the stack.

# Pi Cloud

In this series I'll be setting up a full blown cloud, the likes of which you'd see deployed at Facebook, Google or Amazon (obviously scaled down -- I can't affort millions of servers :p) using Raspberry Pis.

The princple we'll be using while developing this cloud is that nothing is done until it is fully monitored. We'll call this "monitoring driven development."

# Components

So what all do we need to run our own cloud? A cloud capable of supporting a diverse and rich array of applications.

1. Load balancer - so we can spread the incoming requests across multiple servers
2. Application servers - handle requests from the outside world. Could call these "API Servers"
3. Lambda tier - tier to run random jobs. Could call this "background" or "async" tier. Could be expanded to consume the responsibilities of the application servers if we're going for a ["serverless acrhitecture."](https://martinfowler.com/articles/serverless.html)
4. Database tier - persistence for online services
5. Cache - fronts the DB
6. Middleware / Message bus - facilitates one to many communication amongs components. The choices we make here can vastly simplify logging and monitoring.
7. Blob storage - save and serve things like images and files
8. Real time metrics database - so we can query exactly what is happening right now in our services
9. Log collection - bring logs from all services on all servers to our real time db and data warehouse
10. Data warehouse - for offline analysis of logs
11. Service registry - allow services to discover one another as they come and go
12. Chaos Monkey - simulate failures in order to test our fault tolerance (e.g., failover)
13. Network separation - keep our internal/home/whatever network safe if the pi-cloud gets popped
14. Real time abuse protection - prevent spam, child porn, terrorist propaganda, etc. from being uploaded by users of our applications
15. ACL management - control what services and users have access to what
16. Automated Deployment - committed some new code? It should get deployed without us having to think about it or even press a single button
17. Misc machine pool - this is for services to be deployed to that can't run in the application or lambda tier. I debated including this as the entire cloud of Pis could be seen as a "misc machine pool" that we just so happened to deploy a specific confiugration to. I think it warrants inclusion as most organizations have some random long tail of services that don't fit into the broad buckets of: web/database/lambda. These are generally stateful services.
18. Work queues - Application servers will likely need to enqueue work to be done at a later date (e.g., sending emails, scheduling account deletion jobs). This "work" will go to the lambda tier but we'll need a queue to front it in many cases.

For our DB tier, we may get into shard maps. TBD.

# Diagrams

To get us started, lets draw out some diagrams of the proposed cloud.

{% include image.html url="/assets/posts/pi-cloud/first/high-level.svg" description="High level diagram of the relationships between the components mentioned above" %}

{% include image.html url="/assets/posts/pi-cloud/first/deploy.svg" description="Deployment is handled by services declaring their resource needs, stacking constraints and number of instances to run. The deployment service will find machines to run the services on that match the constraints." %}

{% include image.html url="/assets/posts/pi-cloud/first/log-collect.svg" description="All logs will be collected, or sent, to a central message bus. The bus will distribute the logs to services that process or store logs." %}
