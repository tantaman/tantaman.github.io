<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Do LWW Registers Need Vector Clocks or Causal Graphs? ðŸ’­ - Tantamanlands</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/index.css">

<meta name="description" content="Short answer: No. When it comes to a LWW register, Lamport clocks offer all the guarantees we need. Guarantees provided by other clock types are discarded during the merge phase of LWW. A last write wins register is a register where the &#x22;last&#x22; writeâ€¦">
<meta name="keywords" content="programming, distributed, software, statistics, economics">
<meta name="author" content="Matt Wonlaw">
<meta name="copyright" content="Â© 2025 Matt Wonlaw">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Tantamanlands">
<meta property="og:title" content="Do LWW Registers Need Vector Clocks or Causal Graphs? ðŸ’­">
<meta property="og:description" content="Short answer: No. When it comes to a LWW register, Lamport clocks offer all the guarantees we need. Guarantees provided by other clock types are discarded during the merge phase of LWW. A last write wins register is a register where the &#x22;last&#x22; writeâ€¦">
<meta property="og:image" content="https://tantaman.com/img/avatar-icon.png">
<meta property="og:image:alt" content="Tantaman">
<meta property="og:image:width" content="312">
<meta property="og:image:height" content="369">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="distributed">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tantaman.com/img/avatar-icon.png">
<meta name="twitter:image:alt" content="Tantaman">
<meta name="twitter:site" content="@tantaman">
<meta name="twitter:label1" content="Reading time">
<meta name="twitter:data1" content="3-4 minutes">
</head>
<body><header><div class="container"><h1><a href="/">Tantaman</a></h1><nav><a href="/#blog">Blog</a><a href="/#stories">Stories</a><a href="/#notes">Notes</a><a href="/#synthesis">Synthesis</a><a href="/#about">About</a></nav></div></header><main id="static"><h1>Do LWW Registers Need Vector Clocks or Causal Graphs? ðŸ’­</h1><span class="published subtext">Published 2022-10-18</span>
<nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#why-is-lamport-sufficient">Why is Lamport Sufficient?</a></li><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#many-lwws">Many LWWs</a></li></ol></nav><p>Short answer: No. When it comes to a LWW register, <a href="./2022-10-18-lamport-clock">Lamport clock</a>s offer all the guarantees we need. Guarantees provided by other clock types are discarded during the merge phase of LWW.</p>
<p>A last write wins register is a register where the "last" write always wins. Determining when a write happens is usually done via a logical clock. Lamport clocks, vector clocks and causal graphs are a few options here. Lamport clocks being the simplest option.</p>
<p>While a Lamport clock is simple it has a few drawbacks. When comparing two Lamport clocks from two different nodes in a distributed system, we can't tell if an event happened strictly before another event or not. In other words, if a Lamport clock from system A is less than a Lamport clock from system B, A either happened before <strong>or at the same time as</strong> B. We <strong>do know</strong>, however, that B did not happen before A.</p>
<p>From the original <a href="./blog-assets/lamport-clock/paper.pdf">paper</a>:</p>
<blockquote>
<p>We state this condition more formally as follows.</p>
<p><em>Clock Condition.</em> For any events <em>a, b:</em>
if a---> b then C(a) &#x3C; C(b).</p>
<p>Note that we cannot expect the converse condition to
hold as well, since that would imply that any two concurrent events must occur at the same time</p>
</blockquote>
<p>Explored in more detail in this post: <a href="./2022-10-18-lamport-clock">Lamport Clock</a>.</p>
<p>This is the case since the only thing being communicated between peers in the network is a counter. When one peer syncs with another, their counters will be moved up to the max value between the two, ensuring all events with a larger counter are never before events with smaller counters.</p>
<p><img src="./blog-assets/lamport-sufficient/view-of-time.png" alt="view-of-time"></p>
<p>Pictured above, the Lamport view of time does not record that event 2 from node A caused event 3 on node B. The Lamport view only ensures that, after A and B did exchange events, B would not time stamp any new events earlier than what it received from A. Causal graphs and vector clocks, on the other hand, record this information.</p>
<h1 id="why-is-lamport-sufficient"><a aria-hidden="true" tabindex="-1" href="#why-is-lamport-sufficient"><span class="icon icon-link"></span></a>Why is Lamport Sufficient?</h1>
<p>Why is this behavior sufficient for LWW and why do we not need a vector clock or causal graph for LWW registers?</p>
<p>Because of how LWW resolves conflicts. If there are concurrent edits, only one of those edits can be chosen. If we always pick the edit with the largest Lamport timestamp then we're always picking an edit that could not have happened before the other edit. I.e., it doesn't matter if clock A was strictly before or concurrent with clock B. In both cases, we'd choose B. As such, we don't need the extra causal information provided by other clock types.</p>
<p>Multi-value registers, on the other hand, do need something more sophisticated. If we used a Lamport timestamp for a multi-value register then our registers could never say when a concurrent edit was resolved.</p>
<p>To illustrate, see the final panel from the diagram above. A multi-value register based on a Lamport clock would show both values A(2) and B(3). A multi-value register based on a vector clock or causal graph would only show the value B(3) since we know B(3) happened after, and not concurrently with, A(2).</p>
<h1 id="many-lwws"><a aria-hidden="true" tabindex="-1" href="#many-lwws"><span class="icon icon-link"></span></a>Many LWWs</h1>
<p>If you have a system that is comprised of many LWW registers then you may want to start considering keeping a causal history.</p>
<p>The reason here is to try to maintain some transactional guarantees. While LWW throws most of the guarantees of a transaction out the window during the merge step, you can reduce the impact of this at merge time when knowing the full causal history of the system.</p>
<p>To be explored in a later post.</p>
<script src="https://www.googletagmanager.com/gtag/js?id=G-87CH8D1XSS" async></script>
<script src="/ga.js"></script>
</main><footer id="footer"></footer></body>
</html>
