---
title: 'â›“ Query Builder'
tags: [software-engineering, aphrodite]
js: ['https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js']
---

import Mermaid from '/dist/components/Mermaid.js';

[Aphrodite](http://aphrodite.sh) features a rich and type safe [query builder](https://github.com/tantaman/aphrodite/blob/main/packages/integration-tests-ts/src/generated/UserQuery.ts#L17-L66).
The builder can not only query for nodes of a given type but also traverse edges, apply filters, do pagination and more.

As an example, we can traverse from a user to their photos uploaded after 2022-01-01 to users tagged in those photos named Jeff like so:

```typescript
const jeffQuery = user
  .queryPhotos()
  .whereUploadDate(P.greaterThan(new Date('2022-01-01')))
  .queryTaggedUsers()
  .whereName(P.equals('Jeff'));
```

Given that each hop can return a new type of query (e.g., `PhotoQuery` or `UserQuery`) on which to apply filters or take more hops, how do we enable such an API?

The solution is pretty simple. Every invocation to a method on the query builder returns a new query that holds:

1. A reference the previous query
2. A reference to the operation (filter/map/limit/etc) being applied

This forms a linked list which perfectly represents the invocations against the query builder, creating a structure that looks like:

<center>
  <Mermaid
    id="one"
    chart={`graph LR
UserQueryF["UserQuery(name == Jeff)"] --> UserQuery
UserQuery --> PhotoQueryF["PhotoQuery(uploadDate > 2022-01-01)"]
PhotoQueryF --> PhotoQuery`}
  />
</center>

```typescript
const jeffQuery = UserQuery {
  expression: FilterExpression(name == 'Jeff')
  sourceQuery: UserQuery {
    expression: null,
    sourceQuery: PhotoQuery {
      expression: FilterExpression(uploadDate > new Date('2022-01-01'))
      sourceQuery: PhotoQuery {
        expression: null,
        sourceQuery: null,
      }
    }
  }
}
```

Walking the linked list to the end will get you to the root that starts the query off.

In reality the structure is a bit more complicated since we need to constrain queries to only fetch items related to the prior hop but this is the basic idea.

For the interested, a more faithful representation of what happens in practice is reproduced below.

<center>
  <Mermaid
    id="two"
    chart={`graph TD
UserQueryF["UserQuery(name == Jeff)"] --> UserQuery
UserQuery --> HopQueryPtoU["HopQuery(PhotosToUsersEdge)"]
HopQueryPtoU --> PhotoQueryF["PhotoQuery(uploadDate > 2022-01-01)"]
PhotoQueryF --> PhotoQuery
PhotoQuery --> HopQueryUtoP["HopQuery(UsersToPhotosEdge)"]
HopQueryUtoP --> Root["Root(User)"]`}
  />
</center>

Base query classes:
[https://github.com/tantaman/aphrodite/blob/main/packages/query-runtime-ts/src/Query.ts](https://github.com/tantaman/aphrodite/blob/main/packages/query-runtime-ts/src/Query.ts)

Example generated query builder:
[https://github.com/tantaman/aphrodite/blob/main/packages/integration-tests-ts/src/generated/UserQuery.ts#L17-L66](https://github.com/tantaman/aphrodite/blob/main/packages/integration-tests-ts/src/generated/UserQuery.ts#L17-L66)
